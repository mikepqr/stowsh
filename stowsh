#!/usr/bin/env bash

_runcommands() {
    if [[ $DRYRUN == 1 ]] || [[ $VERBOSE -gt 1 ]]; then
        echo "$@"
    fi
    if [[ $DRYRUN != 1 ]]; then
        eval "$@"
    fi
}

echoerr() {
    printf "%s\n" "$*" >&2
}

deperr() {
    echoerr "stowsh requires $1"
}

isgnu() {
    if $1 --version >/dev/null 2>&1; then
        return 1
    else
        return 0
    fi
}

stowsh_setpaths() {
    if command -v grealpath >/dev/null 2>&1; then
        rpcmd="grealpath"
    elif command -v realpath >/dev/null 2>&1; then
        rpcmd="realpath"
    else
        deperr "GNU coreutils"
        return 1
    fi
    if isgnu $rpcmd; then
        deperr "GNU coreutils"
        return 1
    fi
    if command -v gfind >/dev/null 2>&1; then
        findcmd="gfind"
    elif command -v find >/dev/null 2>&1; then
        findcmd="find"
    else
        deperr "GNU findutils"
        return 1
    fi
    if isgnu $findcmd; then
        deperr "GNU findutils"
        return 1
    fi
    if [[ "${USEGIT}" -eq 1 ]]; then
        dlist="list_git_dirs"
        flist="list_git_files"
    else
        dlist="list_dirs"
        flist="list_files"
    fi
    if [[ "$OSTYPE" == "darwin"* || "$OSTYPE" == "freebsd"* ]]; then
        _cp_keep_symlink="-P"
        _cp_deref_symlink="-L"
    else
        _cp_keep_symlink="-d"
        _cp_deref_symlink="-L"
    fi
}

list_dirs() {
    local path="${1-.}"
    $findcmd "${path}" -mindepth 1 -type d -printf "%P\0"
}

list_files() {
    local path="${1-.}"
    $findcmd "${path}" -type f -printf "%P\0" -or -type l -printf "%P\0"
}

list_git_dirs() {
    local path="${1-.}"
    gitfiles=($(git ls-files "$path"))
    if [[ "${#gitfiles[@]}" == 0 ]]; then return; fi
    printf "%s\n" "${gitfiles[@]}" |
        xargs -n1 dirname |
        sort | uniq |
        sed '/^\.$/d' |
        tr '\n' '\0'
}

list_git_files() {
    # list_git_files is a slight problem when there's a mix of untracked and tracked
    # Adding the --others keyword allows the untracked to appear, which is a better
    # default?
    local path="${1-.}"
    gitfiles=($(git ls-files -c -o "$path"))
    if [[ "${#gitfiles[@]}" == 0 ]]; then return; fi
    printf "%s\0" "${gitfiles[@]}"
}

git_writeable() {
    # TODO: Consider if ignored files should be included here ..
    local output
    if output="$(git status --porcelain --ignored -u all ""$@"")" && [[ -z "$output" ]]; then
        return 0 # Safe to write to repo
    fi
    echoerr Target "$@" already in the git-repo with uncomitted changes. Aborting...
    echoerr Output of 'git status --ignored':
    git status --ignored "$@" 1>&2
    return 1
}

git_is_path_inside_repo() {
    local path="${1-.}"
    local output
    if output=$(cd "$path" && git rev-parse --show-toplevel 2>&1 > /dev/null); then
        return 0 # Path is in a git repo 
    else
        return 1
    fi
}

git_clean() {
    local path="${1-.}"
    local output
    if output=$(cd "$path" && git status --porcelain --untracked-files=no) && [ -z "$output" ]; then
        return 0 # Clean git, but may still have untracked files
    else
        return 1
    fi
}

stowsh_list_status() {
    # Compares the files in the source package and displays
    # 1) Missing files
    # 2) Files with different content
    # 3) TODO: Check if target symlink points to package
    #
    # Returns 1 if operation failed.
    stowsh_setpaths || exit 1
    local pkg=$1
    local target=$("$rpcmd" "${2-$PWD}")
    local commands=()
    local messages=()
    local relative
    local branch

    if [[ -e "$pkg" && ! -d "$pkg" ]]; then
        echoerr "The path '$pkg' exists and is not a directory! Aborting."
        exit 1
    fi
    if [[ ! -e "$pkg" ]]; then
        echoerr "The path '$pkg' does not exist! Aborting."
        exit 1
    fi
    if [[ ! -d "$target" ]]; then
        echoerr "The path '$target' is not a directory. Aborting."
        exit 1
    fi
    if [[ "$USEGIT" -eq 1 ]] && ! git_clean "$pkg"; then
        echoerr "Uncommitted changes or no git repository at" "$pkg"
    fi

    echo "Listing package status for $pkg/ at $($rpcmd "$target" -s --relative-to="$PWD")/"
    local GS=""
    [[ "${USEGIT}" -eq 1 ]] && GS="GS | "
    messages+=("${GS}PACKAGE PATH | STATUS | TARGET PATH | TARGET TIMESTAMP")
    while IFS= read -r -d '' f; do
        local src_file
        if [[ -z "$f" ]]; then
            echoerr "ERROR 101 TODO"
            exit 1
        else
            src_file="$pkg/$f"
        fi

        local relative=$($rpcmd "$src_file" -s --relative-to="$pkg")
        local pkg_target="$target/$relative"
        local tgt=$($rpcmd "$pkg_target" -s --relative-to="$target/..")
        #echo pkg="$pkg" target="$target" f="$f" relative="$relative"
        if [[ "${USEGIT}" -eq 1 ]]; then
            gitstatus=$(cd "$pkg" && git status --porcelain "$f")
            if [[ ! -z "${gitstatus}" ]]; then
                gitstatus="${gitstatus:0:2} | "
            else
                gitstatus='  | '
            fi
        else
            gitstatus=""
        fi
        local tgt_type=""
        local src_type=""
        [[ -L "${pkg_target}" ]] && tgt_type="(link)"
        [[ -L "${src_file}" ]] && src_type="(link)"
        if [[ ! -e "$pkg_target" ]]; then
            messages+=("${gitstatus}""$src_file $src_type"" | missing | $tgt | ")
        else
            local newer=""
            [[ "$src_file" -ot "$pkg_target" ]] && newer="newer"
            local older=""
            [[ "$src_file" -nt "$pkg_target" ]] && older="older"
            local timeinfo="${newer}${older}"
            if diff_result=$(diff -q "$src_file" "$pkg_target"); then
                messages+=("${gitstatus}""$src_file"" | match | ""$tgt $tgt_type | ")
            else
                messages+=("${gitstatus}""$src_file"" | diff  | ""$tgt $tgt_type | $timeinfo ")
            fi
        fi
    done < <(list_files "$pkg")
    for cmd in "${commands[@]}"; do
        echo _runcommands "$cmd"
    done
    printf '%s\n' "${messages[@]}" | column -t -s '|' -o '|'
}

stowsh_add_to_pkg() {
    # This function copies to package $1 the source file(s) at path $3
    # The path $3 is given relative to $2 given by the -t TARGET option
    # Returns 1 if operation failed.
    #
    stowsh_setpaths || exit 1
    local pkg=$1
    local target=$("$rpcmd" "${2-$PWD}")
    local pkg_src="${3-.}"
    local commands=()
    local messages=()
    local relative
    local branch

    if [[ -e "$pkg" && ! -d "$pkg" ]]; then
        echoerr "The path '$pkg' exists and is not a directory! Aborting ..."
        exit 1
    fi
    [[ ! -e "$pkg" ]] && mkdir -p "$pkg" && messages+=("Created new package main directory: '$pkg'")

    while IFS= read -r -d '' f; do
        local src_file
        if [[ -z "$f" ]]; then
            src_file="$pkg_src"
        else
            src_file="$pkg_src/$f"
        fi
        relative=$($rpcmd "$src_file" -s --relative-to="$target")
        local pkg_target="$pkg/$relative"
        local pkg_target_dir="$(dirname ""${pkg_target}"")"
        if [[ -e "$pkg_target_dir" && ! -d "$pkg_target_dir" ]]; then
            echoerr "The path '$pkg_target_dir' exists and is not a directory! Aborting ..."
            # TODO : No clean-up of directories made so far
            exit 1
        fi
        if [[ ! -e "$pkg_target_dir" ]]; then
            mkdir -p "${pkg_target_dir}" || (
                echoerr "Error creating directory" "${pkg_target_dir}"
                exit 1
            )
            messages+=("Created new package sub-directory:  '$pkg_target_dir'")
        fi
        if [[ ! -f "$pkg_target" ]]; then
            if [[ "$ADD_PKG_COPY_LINKS" -eq 1 ]]; then
                commands+=("cp $_cp_keep_symlink '$src_file' '$pkg_target'")
            else
                commands+=("cp $_cp_deref_symlink '$src_file' '$pkg_target'")
            fi
            [[ "${USEGIT}" -eq 1 ]] && commands+=("git add '$pkg_target'")
        else
            local diff=1
            [[ -f "$pkg_target" ]] && diff=$(diff -q "$pkg_target" "$src_file")
            if [[ -z "$diff" ]]; then
                messages+=("File '$pkg_target' already matches '$src_file'.")
            else
                if [[ "${USEGIT}" -eq 1 ]]; then
                    git_writeable "$pkg_target" || exit 1
                    if [[ "$ADD_PKG_COPY_LINKS" -eq 1 ]]; then
                        commands+=("cp $_cp_keep_symlink -f '$src_file' '$pkg_target'")
                    else
                        commands+=("cp $_cp_deref_symlink -f '$src_file' '$pkg_target'")
                    fi
                    commands+=("git add '$pkg_target'")
                    messages+=("Git-versioned file '$pkg_target' in has been staged with NEW CONTENTS from '$src_file'.")
                    messages+=("Please review the diff and commit or revert any changes.")
                else
                    echoerr "$pkg_target already exists."
                    if [[ ! $SKIP -eq 1 ]]; then
                        $(
                            cd $pkg
                            git status >/dev/null 2>&1
                        ) || git_suggestion=" or -g for a more git-aware mode."
                        echoerr "Aborting. Rerun with the -s flag to skip errors${git_suggestion}."
                        return 1
                    fi
                fi
            fi
        fi
    done < <(list_files "$pkg_src")

    for cmd in "${commands[@]}"; do
        _runcommands "$cmd"
    done
    for msg in "${messages[@]}"; do
        echo stowsh: "$msg"
    done
}

stowsh_install() {
    stowsh_setpaths || return 1
    local pkg=$1
    local target
    target=$("$rpcmd" "${2-$PWD}")
    local commands=()
    local messages=()

    cd "$pkg" || return 1

    mkdir -p "$target"
    while IFS= read -r -d '' d; do
        commands+=("mkdir -p '$target/$d'")
    done < <($dlist)
    while IFS= read -r -d '' f; do
        local targetf="$target/$f"
        local thisdir
        thisdir=$(dirname "$targetf")
        local relative
        relative=$($rpcmd "$f" --relative-to="$thisdir" --canonicalize-missing)

        if [[ ! -e "$targetf" ]]; then
            commands+=("ln -s '$relative' '$targetf'")
        else
            local diff=1
            [[ "${LINK_REPLACES_EQUALS}" -eq 1 && -f $targetf ]] && diff=$(diff -q "$f" "$targetf")
            if [[ -z "$diff" ]]; then
                commands+=("ln -s -f '$relative' '$targetf'")
            else
                if [[ "${USEGIT}" -eq 1 ]]; then
                    git_writeable "$f" || exit 1
                    commands+=("mv -f '$targetf' '$f'")
                    commands+=("ln -s '$relative' '$targetf'")
                    messages+=("Git-versioned file '$f' in '$pkg' has been replaced with the contents of '$targetf'.")
                    messages+=("Please review the diff and commit or revert any changes.")
                else
                    echoerr "$targetf already exists."
                    if [[ ! $SKIP -eq 1 ]]; then
                        echoerr "Aborting. Rerun with the -s flag to skip errors."
                        return 1
                    fi
                fi
            fi
        fi
    done < <($flist)

    for cmd in "${commands[@]}"; do
        _runcommands "$cmd"
    done
    for msg in "${messages[@]}"; do
        echo "stowsh:" "$msg"
    done
}

stowsh_uninstall() {
    stowsh_setpaths || return 1
    local pkg=$1
    local target
    target=$("$rpcmd" "${2-$PWD}")
    local commands=()

    cd "$pkg" || return 1

    while IFS= read -r -d '' f; do
        local targetf="$target/$f"
        if [[ $($rpcmd "$targetf") == $($rpcmd "$f") ]]; then
            commands+=("rm '$targetf'")
        elif [[ -f "$targetf" ]]; then
            echoerr "$targetf does not point to to $($rpcmd "$f")."
            if [[ ! $SKIP -eq 1 ]]; then
                echoerr "Aborting. Rerun with the -s flag to skip errors."
                return 1
            fi
        elif [[ ! -f "$targetf" ]]; then
            echoerr "$targetf does not exist. Nothing to do."
            if [[ ! $SKIP -eq 1 ]]; then
                echoerr "Aborting. Rerun with the -s flag to skip errors."
                return 1
            fi
        fi
    done < <($flist)

    while IFS= read -r -d '' d; do
        commands+=("[[ -d '$target/$d' ]] && $findcmd '$target/$d' -type d -empty -delete")
    done < <($dlist)

    for cmd in "${commands[@]}"; do
        _runcommands "$cmd"
    done
}

stowsh_help() {
    echo "Usage: $0 [-D] [-n] [-s] [-g] [-r] [-v[v]] [-l] [-t TARGET] PACKAGES..."
    echo "       $0 [-d] [-n] [-s] [-g] [-r] [-v[v]] [-t TARGET] -a PACKAGE FILES..."
}

if [ "$0" = "$BASH_SOURCE" ]; then
    UNINSTALL=0
    DRYRUN=0
    SKIP=0
    LINK_REPLACES_EQUALS=0
    ADD_TO_PACKAGE=
    ADD_PKG_COPY_LINKS=1
    USEGIT=0
    CONTINUE_COMMIT=0
    TARGET="$PWD"
    SOURCES=()
    while [[ "$@" ]]; do
        if [[ $1 =~ ^- ]]; then
            OPTIND=1
            while getopts ":vhDsnrdgclt:a:" opt; do
                case $opt in
                    h)
                        stowsh_help
                        exit 0
                        ;;
                    D)
                        UNINSTALL=1
                        [[ ! -z "$ADD_TO_PACKAGE" ]] && echoerr "Options -a and -D may not be given together. Aborting..." && exit 1
                        ;;
                    n)
                        DRYRUN=1
                        ;;
                    r)
                        LINK_REPLACES_EQUALS=1
                        ;;
                    d) # --dereference
                        ADD_PKG_COPY_LINKS=0
                        ;;
                    s)
                        SKIP=1
                        ;;
                    v)
                        VERBOSE=$((VERBOSE + 1))
                        ;;
                    g)
                        USEGIT=1
                        ;;
                    c)
                        CONTINUE_COMMIT=1
                        ;;
                    l)
                        LIST_PKG_STATUS=1
                        ;;
                    t)
                        TARGET="$OPTARG"
                        ;;
                    a)
                        [[ ! -z "${ADD_TO_PACKAGE}" ]] && echoerr Only one -a add-package option may be supplied && exit 1
                        ADD_TO_PACKAGE="$OPTARG"
                        [[ "$UNINSTALL" -eq 1 ]] && echoerr "Options -a and -D may not be given together. Aborting..." && exit 1
                        ;;
                    *)
                        echo "'$OPTARG' is an invalid option/flag"
                        exit 1
                        ;;
                esac
            done
            shift $((OPTIND - 1))
        else
            SOURCES+=("$1")
            shift
        fi
    done

    if [[ ${#SOURCES[@]} -eq 0 ]]; then
        stowsh_help
        exit 1
    fi
    if [[ ! -z "${LIST_PKG_STATUS}" ]]; then
        for i in ${!SOURCES[*]}; do
            pkg=${SOURCES[$i]}
            stowsh_list_status "$pkg" "$TARGET"
        done
        exit 0
    fi
    if [[ ! -z "${ADD_TO_PACKAGE}" ]]; then
        if [[ "$USEGIT" -eq 1 ]]; then 
            if ! git_is_path_inside_repo "${ADD_TO_PACKAGE}"; then
                echoerr "No git repository at \'${ADD_TO_PACKAGE}\'. Aborting."
                exit 1
            fi
            if ! git_clean "${ADD_TO_PACKAGE}" && ! [[ $CONTINUE_COMMIT -eq 1 ]]; then
                echoerr "Unclean git repository at \'${ADD_TO_PACKAGE}\', without continue-commit (-c). Aborting ..."
                exit 1
            fi
        fi
        for i in ${!SOURCES[*]}; do
            if [[ $VERBOSE -gt 0 ]]; then echoerr "Adding to ${ADD_TO_PACKAGE}: '${TARGET}' '${SOURCES[$i]}'"; fi
            stowsh_add_to_pkg "${ADD_TO_PACKAGE}" "${TARGET}" "${SOURCES[$i]}"
        done
        exit 0
    fi
    for i in ${!SOURCES[*]}; do
        pkg=${SOURCES[$i]}
        if [[ $UNINSTALL -eq 1 ]]; then
            if [[ $VERBOSE -gt 0 ]]; then echoerr "Uninstalling $pkg from $TARGET"; fi
            stowsh_uninstall "$pkg" "$TARGET"
        else
            if [[ $VERBOSE -gt 0 ]]; then echoerr "Installing $pkg to $TARGET"; fi
            stowsh_install "$pkg" "$TARGET"
        fi
    done
fi
# vim: ts=4 sts=4 sw=4
